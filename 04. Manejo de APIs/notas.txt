123
JSON (JavaScript Object Notation)es un formato de datos ligero y popular para intercambiar información entre sistemas y se puede utilizar en varios lenguajes de programación.

JSON se compone de dos tipos de estructuras de datos: objetos y arrays. Un objeto es una colección de pares clave-valor, donde las claves son strings y los valores pueden ser strings, números, booleanos, objetos o arrays. Por ejemplo:

HTTP (HyperText Transfer Protocol) es un protocolo de comunicación que permite la transferencia de información en Internet. Es la base para la comunicación entre los navegadores y los servidores web, utilizándose para transmitir contenidos como textos, imágenes y vídeos.

HTTP se desarrolló en la década de 1990 y se basa en un modelo cliente-servidor, donde un cliente (navegador web) realiza solicitudes a un servidor para obtener información y el servidor responde con los datos solicitados. HTTP utiliza TCP (Transmission Control Protocol) como protocolo de transporte para garantizar una entrega de datos confiable.

HTTP utiliza métodos para especificar el tipo de operación que se debe realizar en el servidor. Los métodos principales son GET, POST, PUT y DELETE. El método GET se utiliza para solicitar datos del servidor, mientras que POST se utiliza para enviar información al servidor. PUT se utiliza para actualizar información en el servidor y DELETE se utiliza para eliminar información.

Además de los métodos, HTTP utiliza códigos de status para indicar el resultado de la operación realizada. Los códigos de status van del 100 al 599 y se dividen en cinco clases:

1xx: Informaciones
2xx: Éxito
3xx: Redirección
4xx: error del cliente
5xx: error del servidor
Si quieres profundizar en tus conocimientos sobre este protocolo, te recomendamos nuestro curso HTTP: La base de internet.

Los patrones de diseño, también conocidos como design patterns, son soluciones reutilizables a problemas comunes de desarrollo de software. Surgieron en la década de 1990, cuando un grupo de desarrolladores identificó que muchos proyectos de software presentaban problemas similares, que podían resolverse con soluciones similares.

Los patrones de diseño se pueden dividir en tres categorías:

Patrones de creación: son patrones que se ocupan de la creación de objetos, con el objetivo de garantizar la flexibilidad y la reutilización del código. Algunos ejemplos de patrones de creación son: Factory Method, Builder y Singleton.
Patrones de estructura: son patrones que tratan de la organización de objetos en estructuras más grandes, buscando simplificar la comunicación entre objetos y reducir el acoplamiento entre ellos. Algunos ejemplos de patrones de estructura son: Adapter, Facade y Composite.
Patrones de comportamiento: son patrones que tratan la comunicación entre objetos, buscando definir el comportamiento esperado en situaciones específicas. Algunos ejemplos de patrones de comportamiento son: Observer, Command y Strategy.
Al utilizar patrones de diseño, es posible aumentar la calidad del código, haciéndolo más legible, flexible y fácil de mantener.

Las bibliotecas y frameworks en Java, y también en otros lenguajes de programación, son herramientas esenciales para quienes trabajan con programación, ya que ayudan a reducir la cantidad de trabajo requerido para construir aplicaciones, debido a que brindan funcionalidades listas para usar, lo que permite a los desarrolladores centrarse en la lógica de negocio de los proyectos, en lugar de preocuparse por problemas técnicos que son comunes y que ya tienen soluciones listas para usar.

En Java, las bibliotecas son colecciones de clases e interfaces que ofrecen una serie de recursos y funcionalidades listas para usar. Generalmente se distribuyen como archivos JAR (Java Archive), que son paquetes de archivos Java que contienen clases y otros recursos, como imágenes y archivos de configuración. Las bibliotecas se pueden importar en proyectos Java y usarse directamente en el código para implementar funcionalidades específicas, como manipulación de archivos, conexión a bases de datos, criptografía, etc.

Los frameworks, por otro lado, son estructuras de software que proporcionan una arquitectura básica para desarrollar aplicaciones. Incluyen bibliotecas, patrones y mejores prácticas para guiar el proceso de desarrollo de aplicaciones. Se puede considerar un framework como una "fábrica de aplicaciones estandarizadas" que proporciona los componentes necesarios para crear una aplicación, así como un conjunto de reglas y pautas para guiarlo en el proceso, como por ejemplo una serie de carpetas en donde colocar ciertos archivos.

Hay muchos frameworks populares en Java, cada uno con sus propias características y objetivos. Algunos ejemplos incluyen Spring Framework, que es un framework que facilita la creación de aplicaciones web y APIs Rest complejas en Java; Hibernate, que es un framework de mapeo objeto-relacional y simplifica enormemente el proceso de integración de una aplicación Java con una base de datos relacional.

anzado oficialmente en Java 16, pero disponible desde Java 14 de forma experimental, Record es una característica que le permite representar una clase inmutable, que contiene solo atributos, constructor y métodos de lectura, de una manera muy simple y sencilla.

Esta característica encaja perfectamente cuando necesitamos crear un objeto solo para representar datos, sin ningún tipo de comportamiento.

Para crear una clase inmutable, sin utilizar Record, era necesario escribir mucho código. Veamos un ejemplo de una clase que representa un teléfono:
public final class Telefono {
    private final String codigoDeArea;
    private final String numero;

    public Telefono(String codigoDeArea, String numero) {
        this.codigoDeArea = codigoDeArea;
        this.numero = numero;
    }

    @Override
    public int hashCode() {
        return Objects.hash(codigoDeArea, numero);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        } else if (!(obj instanceof Telefono)) {
            return false;
        } else {
            Telefono other = (Telefono) obj;
            return Objects.equals(codigoDeArea, other.codigoDeArea)
              && Objects.equals(numero, other.numero);
        }
    }

    public String getCodigoDeArea() {
        return this.codigoDeArea;
    }

    public String getNumero() {
        return this.numero;
    }
}

Ahora con Record, todo ese código puede ser resumido con una única linea:
public record Telefono(String codigoDeArea, String numero){}

En el fondo, Java transformará ese Record en una clase inmutable, muy similar al código mostrado anteriormente.

La inmutabilidad, mencionada anteriormente al hablar de Record, es un concepto importante en Java, que se refiere a la capacidad de un objeto de no poder modificarse una vez creado. Existen algunas clases que son inmutables por defecto, como las clases String, Integer, Boolean, entre otras. Esto significa que una vez creado un objeto de estas clases, su estado no se puede modificar.

Ejemplifiquemos. Dado el record a continuación:

public record Estudiante(String nombre, int edad) {}

Una vez creado un objeto Estudiante, sus valores no se pueden modificar:

Estudiante estudiante1 = new Estudiante(“Alicia”, 19);
Copia el código
Observe que después de esta creación, no puedo setear otro nombre o edad para el objeto estudiante1.

estudiante1.setNombre(“Maria”); //no es posible
estudiante1.nombre = “Maria”; //no es posible

Cualquiera de los intentos anteriores presentará un error de compilación, ya que no es posible asignar ningún otro nombre a la variable estudiante1.

Respecto al record, está bastante claro, ¿verdad? Pero ¿qué pasa con la clase String, por ejemplo? Puedo hacer los siguiente en el código:

String nombre = “Maria”;
nombre = “Alice”;

Si la clase String es inmutable, lo correcto sería que no pueda asignar el contenido “Alice” a la variable nombre, ¿correcto?

En el caso de la clase String y otras clases inmutables que mencioné anteriormente, la variable nombre contiene una referencia al objeto de clase String que contiene el valor "Maria".

Sin embargo, cuando intentas cambiar el valor del String, lo que realmente sucede es que se crea un nuevo objeto de la clase String con el nuevo valor, y la variable se actualiza para almacenar una referencia al nuevo objeto.

Por lo tanto, podemos decir que la clase String es inmutable, porque una vez que se crea un objeto de la clase String, no se puede cambiar. Sin embargo, las variables que almacenan referencias a objetos de la clase String se pueden actualizar para hacer referencia a nuevos objetos, que se crean a partir del contenido del objeto original.

La inmutabilidad es importante por varias razones, entre ellas:

Concurrencia: los objetos inmutables son seguros de usar en entornos concurrentes (o paralelismo) ya que no hay necesidad de sincronización.
Seguridad: los objetos inmutables están protegidos contra cambios accidentales o maliciosos.
Rendimiento: los objetos inmutables se pueden almacenar en caché y reutilizar, lo que puede mejorar el rendimiento.

Aprendimos que cuando ocurre una excepción, Java le permite manejar el error usando la declaración try-catch. Sin embargo, también existe el bloque finally, que es opcional, pero puede resultar útil en determinadas situaciones.

Finally se utiliza para ejecutar un bloque de código independientemente de si ocurre o no una excepción, es decir, siempre se ejecuta. Esto puede resultar útil cuando necesitamos ejecutar código tanto en el try (si no se produce una excepción) como en el catch (si se produce una excepción). Por ejemplo, supongamos que tiene el siguiente código:

try {
  metodoQuePuedeLanzarExcepcion();
  System.out.println("Se ejecutó");

  System.out.println("Finalizó!");
} catch (Exception e) {
  System.out.println("Dio un error!");

  System.out.println("Finalizó!");
}
Copia el código
Observe en el código anterior que la instrucción System.out.println("Finalizó!"); siempre debe ejecutarse, independientemente de si ocurrió una excepción o no. Pero el problema es que acabó teniendo que duplicarse tanto en el try como en el catch. El bloque finally nos ayuda a evitar esta duplicación de código:

try {
  metodoQuePuedeLanzarExcepcion();
  System.out.println("Se ejecutó");
} catch (Exception e) {
  System.out.println("Dio un error!");
} finally {
  System.out.println("Finalizó!");
}
Copia el código
Note que ahora la instrucción aparece solo una vez, dentro del bloque finally, evitando así duplicaciones innecesarias de código.

Finally se usa a menudo en situaciones en las que es necesario limpiar recursos, cerrar conexiones de bases de datos o cerrar archivos que se abrieron en el bloque try.

En Java, las excepciones están organizadas en una jerarquía de clases. Todas las excepciones son subclases de la clase Throwable, que tiene dos subclases principales: Exception y Error.

Las excepciones que heredan de la clase Exception se denominan excepciones verificadas (checked exceptions). Esto significa que estas excepciones deben ser tratadas explícitamente en un bloque try-catch o declaradas en una cláusula throws en la firma del método (luego de los paréntesis de los parámetros y antes de las llaves). Un ejemplo es la clase IOException, que indica un problema relacionado con la lectura/escritura de datos.

Las excepciones que heredan de la clase Error representan errores hacen que el sistema no se pueda recuperar, como falta de memoria o fallas internas. Un ejemplo es la clase OutOfMemoryError, que indica que Java no pudo obtener suficiente memoria del sistema operativo para ejecutar correctamente la aplicación.

Además, también existe la clase RuntimeException, que es una subclase directa de Exception, y las clases que heredan de ella se denominan excepciones no verificadas (unchecked exception). Las excepciones no verificadas indican errores lógicos en el código, como la NullPointerException, que indica acceso a algún atributo o método de un objeto que es null, es decir, que no fue instanciado o se le asignó el valor nulo.

Al manejar excepciones en un bloque try-catch, es importante considerar la jerarquía de excepciones. Es posible capturar excepciones de una clase madre en un bloque catch que captura excepciones de una clase hija. Sin embargo, lo contrario no es posible. Esto significa que si un bloque catch captura excepciones de una clase hija, no podrá capturar excepciones de una clase madre. Por ejemplo, si coloco en el catch que quiero capturar RuntimeException, no voy a poder capturar excepciones de la clase Exception (porque es la madre de RuntimeException) dentro de ese catch. Pero si en ese bloque catch digo que voy a capturar Exception, entonces toda excepcion que sea Exception o que herede de Exception (como RuntimeException) sí entrará en ese bloque catch.

try{
    //Ejemplo de un código a ser ejecutado
}catch(RuntimeException e){
    //Van a entrar las excepciones que sean del tipo RuntimeException o hijas de ella,
    // pero no las del tipo Exception (que es la madre de RuntimeException)
}catch (Exception e){
    //Van a entrar todas las excepciones del tipo Exception o hijas de ella
    //incluida las excepciones del tipo RuntimeException
}

A partir de Java 7, el lenguaje introdujo una nueva característica llamada "multi-catch", que le permite capturar múltiples excepciones en un solo bloque catch. Esta funcionalidad puede hacer que el código sea más conciso y legible, reduciendo la repetición del código.

Usar multi-catch es muy simple. En lugar de tener varios bloques catch para manejar diferentes excepciones, puede agruparlos en un solo bloque usando el caracter | para separar las excepciones. Por ejemplo, supongamos que escribió el siguiente código:

try {
    metodoQuePuedeLanzarUnaExcepcion();
} catch (NumberFormatException e) {
    System.out.println("tratando error...");
} catch (IllegalArgumentException e) {
    System.out.println("tratando error...");
}
Copia el código
Como el tratamiento del error es el mismo para ambas excepciones, el código anterior podría haberse escrito usando multi-catch:

try {
    metodoQuePuedeLanzarUnaExcepcion();
} catch (NullPointerException | IllegalArgumentException e) {
    System.out.println("tratando error...");
}
Copia el código
En el ejemplo anterior, tratamos con dos excepciones diferentes: NullPointerException e IllegalArgumentException. Si alguna de estas excepciones se produce dentro del bloque try, se ejecutará el mismo bloque catch.

Una nota importante a recordar es que el uso de multi-catch solo se permite para excepciones que no están relacionadas por una jerarquía de herencia. Si dos excepciones comparten una jerarquía de herencia, debes manejarlas en bloques catch separados.

Java cuenta con un paquete llamado java.io, el cual es uno de los paquetes más importantes del lenguaje, ya que proporciona clases e interfaces para entrada y salida de datos en diversos formatos, como archivos, red, teclado, entre otros. Conozcamos las clases principales de este paquete.

La clase File
La clase File representa un archivo o directorio en el sistema de archivos de la computadora, lo que le permite crear, eliminar, listar y manipular archivos y directorios. Para crear un objeto File, debe pasar la ruta del archivo o directorio como argumento al constructor. Por ejemplo:

File file = new File("C:\\miArchivo.txt");
Copia el código
En el código anterior se creó un objeto File que apunta al archivo "miArchivo.txt" ubicado en la raíz del disco C:.

La clase File tiene varios métodos útiles para interactuar con archivos y directorios, como exists(), canRead(), canWrite(), isDirectory(), isFile(), mkdir() y delete().

La clase FileReader y FileWriter
Las clases FileReader y FileWriter se utilizan para leer y escribir datos en archivos de texto; la clase FileReader lee caracteres de un archivo de texto, mientras que la clase FileWriter escribe los caracteres.

Para usar la clase FileReader, necesita crear un objeto FileReader pasando un objeto File como argumento, que contenga la ruta del archivo que quieres leer. Luego puede leer los datos del archivo usando el método read() o read(char[]). Por ejemplo:

File file = new File("C:\\miArchivo.txt");
FileReader reader = new FileReader(file);

int data = reader.read();
while (data != -1) {
    System.out.print((char) data);
    data = reader.read();
}
reader.close();
Copia el código
En el código anterior se lee el contenido del archivo "miArchivo.txt" y se imprime su contenido en la consola.

La clase FileWriter sigue el mismo proceso, pero haciendo lo contrario, es decir, escribiendo caracteres en el archivo. Por ejemplo:

File file = new File("C:\\salida.txt");
FileWriter writer = new FileWriter(file);
writer.write("Hola mundo!");
writer.close();
Copia el código
En el código anterior, se escribe un mensaje en el archivo llamado "salida.txt".

El paquete java.io también proporciona otras clases útiles como:

BufferedReader y BufferedWriter: se utilizan para leer y escribir archivos de texto de manera eficiente, leyendo y escribiendo una línea a la vez. Utilizan un búfer para almacenar datos, lo que hace que la lectura y la escritura sean más rápidas que cuando se hacen de un carácter a la vez;
FileInputStream y FileOutputStream: se utilizan para leer y escribir datos binarios en un archivo. Se utilizan para leer y escribir datos en archivos que no son de texto, como imágenes y archivos de audio;
ObjectInputStream y ObjectOutputStream: se utilizan para leer y escribir objetos en archivos. Esto le permite almacenar objetos Java en archivos para su uso posterior o para transferirlos entre diferentes aplicaciones.

Aprendimos cómo guardar un archivo a través de la clase FileWriter, pero si desea hacer lo contrario, es decir, leer el contenido de un archivo existente en Java, puede hacerlo usando la clase Scanner.

La clase Scanner es una clase estándar de Java que le permite leer datos de diferentes fuentes, incluidos archivos. Para leer un archivo con esta clase, simplemente cree una instancia de la misma y pase un objeto de tipo File como argumento, que contenga la ruta del archivo. Por ejemplo:

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class LecturaDeArchivo{
    public static void main(String[] args) {
        try {
            File archivo = new File("archivo.json");
            Scanner scanner = new Scanner(archivo);

            while (scanner.hasNextLine()) {
                String linea = scanner.nextLine();
                System.out.println(linea);
            }
            scanner.close();
        } catch (FileNotFoundException e) {
            System.out.println("Archivo no encontrado!");
        }
    }
}
Copia el código
En el código anterior, leemos un archivo llamado archivo.json e imprimimos el contenido del archivo línea por línea en la consola. El método hasNextLine() verifica si hay más líneas para leer, mientras que el método nextLine() lee la siguiente línea del archivo.

La clase Scanner también se puede utilizar para leer datos de entrada de otras fuentes, como el teclado y strings. Además, ofrece muchas opciones para personalizar la forma en que se leen los datos, incluida la capacidad de utilizar expresiones regulares para analizar el texto.